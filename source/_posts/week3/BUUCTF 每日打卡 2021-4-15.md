---
title: BUUCTF 每日打卡 2021-4-15
date: 2021-04-15
tags: Crypto
mathjax: true
---

## BUUCTF 每日打卡 2021-4-15

## 引言

今天也是元气满满的一天（打哈欠）



## childRSA

题目给了 n和c
照例碰运气[爆破 n](http://factordb.com/)：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210415214932298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
啊这
真让我爆破出来了
然后就是 RSA 常规操作
代码如下：
```python
from Crypto.Util.number import *

# p, q, c, n
e = int('0x10001', 16)
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```
结果为：NCTF{Th3r3_ar3_1ns3cure_RSA_m0duli_7hat_at_f1rst_gl4nce_appe4r_t0_be_s3cur3}



## bbbbbbrsa

附件 python2 加密代码：
```python
from base64 import b64encode as b32encode
from gmpy2 import invert,gcd,iroot
from Crypto.Util.number import *
from binascii import a2b_hex,b2a_hex
import random

flag = "******************************"

nbit = 128

p = getPrime(nbit)
q = getPrime(nbit)
n = p*q

print p
print n

phi = (p-1)*(q-1)

e = random.randint(50000,70000)

while True:
	if gcd(e,phi) == 1:
		break;
	else:
		e -= 1;

c = pow(int(b2a_hex(flag),16),e,n)

print b32encode(str(c))[::-1]

# 2373740699529364991763589324200093466206785561836101840381622237225512234632
```
这个注释就很魔性
一猜就知道是 c
另一个附件内容为：
p = 177077389675257695042507998165006460849
n = 37421829509887796274897162249367329400988647145613325367337968063341372726061
c = ==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM

根据加密代码，c 经过了 base64 加密并且倒序输出了
为了保险起见，还是先解码给出的 c
代码如下：
```python
import base64
import math
from Crypto.Util.number import *

c = '==gMzYDNzIjMxUTNyIzNzIjMyYTM4MDM0gTMwEjNzgTM2UTN4cjNwIjN2QzM5ADMwIDNyMTO4UzM2cTM5kDN2MTOyUTO5YDM0czM3MjM'[::-1]
base64_bytes = c.encode('ascii')
message_bytes = base64.b64decode(base64_bytes)
message = message_bytes.decode('ascii')
print(message)
c = int(message)
```
c = 2373740699529364991763589324200093466206785561836101840381622237225512234632
啊这
跟注释一模一样
解密代码：
```python
p = 177077389675257695042507998165006460849
n = 37421829509887796274897162249367329400988647145613325367337968063341372726061
q = n//p
phi = (p-1)*(q-1)

for e in range(50000, 70000):
    if math.gcd(e, phi) == 1:
        d = inverse(e, phi)
        m = str(long_to_bytes(pow(c, d, n)))
        if '{' in m and '}' in m:
            print(m)
```
结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210415215614224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)



## 结语

啊。。。好像也没什么好说的
希望继续坚持