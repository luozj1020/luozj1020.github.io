---
title: BUUCTF 每日打卡 2021-4-9
date: 2021-04-09
tags: Crypto
mathjax: true
---

## BUUCTF 每日打卡 2021-4-9

## 引言

疲惫的周五
塞满的周末
难受



## Cipher

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409231522338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
除了“公平的玩吧（密钥自己找）”比较可疑外似乎没什么线索了
让人摸不着头脑
原本以为是普通的替换密码，尝试[爆破](https://quipqiup.com/)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409232101709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
没有结果

只能找 [wp](https://blog.csdn.net/MikeCoke/article/details/106105451)

“公平的玩吧”翻译成英文为 playfair
这是Playfair密码（又是没见过的密码）
[普莱费尔密码百度百科](https://baike.baidu.com/item/playfair%E5%AF%86%E7%A0%81/8999814?fr=aladdin)
[Playfair Cipher解密工具](http://rumkin.com/tools/cipher/playfair.php)



## basic rsa

这题非常简单，就是最基础的 RSA
甚至给了你 p, q
直接上解密代码：
```python
from Crypto.Util.number import *

p = 262248800182277040650192055439906580479
q = 262854994239322828547925595487519915551
e = 65533
c = 27565231154623519221597938803435789010285480123476977081867877272451638645710
n = p*q
phi = (p-1)*(q-1)
d = inverse(e, phi)

m = pow(c, d, n)
print(long_to_bytes(m))
```
得到 flag{B4by_Rs4}



## 达芬奇密码

附件内容：
达芬奇隐藏在蒙娜丽莎中的数字列:1 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 17711 
记录在达芬奇窗台口的神秘数字串:36968853882116725547342176952286
一脸懵逼
怀疑可能和《达芬奇密码》这部小说有关（出题人经常干这事），可惜我没有读过
只好求助 wp，据说提到了斐波那契数列
一看还这是，只不过是乱序的
于是容易猜到数字串也是乱序的，并且和数字列的乱序一样
解密代码如下：
```python
a = '1 233 3 2584 1346269 144 5 196418 21 1597 610 377 10946 89 514229 987 8 55 6765 2178309 121393 317811 46368 4181 1 832040 2 28657 75025 34 13 17711'
list_a = a.split(' ')
m = '36968853882116725547342176952286'

list_f = [1, 1]
for i in range(0, len(list_a)-2):
    list_f.append(list_f[i] + list_f[i+1])

flag = '3'
list_a[0] = ''
for i in range(1, len(list_f)):
    flag += m[list_a.index(str(list_f[i]))]
print(flag)
```
因为 index() 是从前往后找的，而 list_a 中有两个 '1'，所以第一位第二位会重复
而易知 flag 第一位为 '3' ，所以这里选择用把 list_a 的第 0 位直接换成 '' 这种简单粗暴的办法来防止出错



## 结语

写完其实已经第二天了
希望继续坚持