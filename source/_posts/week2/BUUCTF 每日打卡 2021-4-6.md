---
title: BUUCTF 每日打卡 2021-4-6
date: 2021-04-06
tags: Crypto
mathjax: true
---

## BUUCTF 每日打卡 2021-4-6

## 引言

假期如期结束了
作业在 deadline 之前写完了，却不知道为什么感觉很疲倦
这大概就是所谓的“假期综合征”吧



## 异性相吸

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210406164650644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
??? 兄弟，你的思想很危险(滑稽)
解压后有两个文件 key.txt 和 密文.txt
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210406164744313.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210406164759249.png)
不知所云
但是根据题目推断，大概要对两条字符串之间进行操作
“异性相吸” 大概指要对两个字符串之间进行异或操作
代码如下：
```python
key = 'asadsasdasdasdasdasdasdasdasdasdqwesqf'
with open(r'D:\BUUCTF\Crypto\异性相吸\b8c1caee-43d6-42ee-aecc-d72502a5ade2\密文.txt', 'r') as f:
    m = f.read()

c = ''
for i in range(len(key)):
    c += chr(ord(m[i]) ^ ord(key[i]))
print(c)
```
得到 flag{ea1bc0988992276b7f95b54a7435e89e}



## 还原大师

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040616532680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
题目中三处未知处均为大写字母，而且已知 MD5 加密后的部分密文
根据哈希函数的基本特征：原始输入有微小改动，哈希值的变化也会很大
我们只需用三个循环爆破结果，与 MD5 码对应即可，且不用担心 MD5 码缺失的影响
而且我们只改动三个字母，也不用担心哈希碰撞
代码如下：
```python
import hashlib

for i in range(26):
    for j in range(26):
        for k in range(26):
            test = 'TASC' + chr(ord('A') + i) + 'O3RJMV' + chr(ord('A') + j) + 'WDJKX' + chr(ord('A') + k) + 'ZM'
            s = hashlib.md5(test.encode('utf8')).hexdigest().upper()
            if s[0:4] == 'E903':
                print(s)
```
结果唯一： E9032994DABAC08080091151380478A2



## RSAROLL

题目给了花括号里面两个数字和后面一长串数字
花括号里面的应该分别是 n 和 e ，而后面一串应该就是密文
根据题目 “RSAROLL” ，推测是将 flag 拆分之后加密
先分解 n：![在这里插入图片描述](https://img-blog.csdnimg.cn/20210406171629828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
得到 p, q
再按照 RSA 加密的一般算法进行解密即可
代码如下：
```python
from Crypto.Util.number import *

n = 920139713
p = 18443
q = 49891
e = 19

with open('data.txt', 'r') as f:
    list_c = f.readlines()[2:]

phi = (p-1)*(q-1)
d = inverse(e, phi)
flag = ''
for c in list_c:
    c = c.replace('\n', '')
    m = pow(int(c), d, n)
    flag += str(long_to_bytes(m)).replace('\'', '').replace('b', '')
print(flag)
```
实际上解出来每个 m 值就是对应的 ascii 码了，这里用 long_to_bytes 实际上是杀鸡用牛刀了
不过为了保险起见（比如会有 flag 不是逐位加密的情况，而是拆分成一段一段的情况），还是建议 long_to_bytes ，也不费事



## 结语

希望能坚持（打哈欠）