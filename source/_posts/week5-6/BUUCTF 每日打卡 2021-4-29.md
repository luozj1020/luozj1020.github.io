---
title: BUUCTF 每日打卡 2021-4-29
date: 2021-04-29
tags: Crypto
mathjax: true
---

## BUUCTF 每日打卡 2021-4-29

## 引言

蓝帽杯就一道 crypto 
又是斐波那契数列，又是 AES
网上查到什么斐波那契数列双混沌加密
反正就是没做出来。。。
等什么时候 wp 出来再说吧。。。



## boom

附件是一个 .exe 文件
不会是个 re 题吧。。。
在命令行打开（如果不在命令行打开，最后输出会直接关闭窗口）
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429185222439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
Do you like van♂ you see?（大雾）
下一步
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429185246243.png)
提交 md5
可以直接[查询](https://www.cmd5.com/)得到
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429184816708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
输入结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429185334753.png)
下一步
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429185357601.png)
解三元一次方程组
当然你可以手算
这里我们直接用 sagemath 计算（躺）
结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429185524985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
最后一步：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429185617123.png)
还是用 sagemath 求解
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429185656219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
输入其中一个解即可
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021042918572871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
当然你可以 re [doge]
把它丢尽 IDA 里面，可以得到程序的框架
这里用的的软件是 IDA Freeware 7.0
先看输出 flag 的部分：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429190130563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
发现 flag 是由三部分组成
第一部分：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429185912455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
第二部分：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429190033880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
第三部分：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429190054324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
容易知道 flag 即为上面三部分答案拼接而成



## B@se

附件内容如下：
```cpp
密文：MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD==
JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/

oh holy shit, something is missing...
```
第一行是密文
第二行容易猜到是重新排列的 Base64 编码对照表
只是其中几个字符缺失了
编写代码：
```python
def judge(key, start, end):
    s = ''
    for i in range(start, end+1):
        if not chr(i) in key:
            s += chr(i)
    return s
unknown = judge(key, ord('A'), ord('Z')) + judge(key, ord('a'), ord('z')) + judge(key, ord('0'), ord('9'))
unknown_list = list(unknown)
print(unknown_list)
```
可以得出缺失的字符为 ['j', 'u', '3', '4']
对其进行排列组合，替换对照表中缺失的字符
然后按照 Base64 的编码规则编写程序
代码如下：

```python
import itertools

c = 'MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD=='
key = 'JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/'

def decrypt(c, key):
    b = ''
    s = ''
    for i in range(len(c)):
        if c[i] == '=':
            b += '0'*6
        else:
            b += bin(list(key).index(c[i]))[2:].zfill(6)
    for i in range(0, len(b), 8):
        s += chr(int(b[i:i+8], 2))
    print(s)

def judge(key, start, end):
    s = ''
    for i in range(start, end+1):
        if not chr(i) in key:
            s += chr(i)
    return s
unknown = judge(key, ord('A'), ord('Z')) + judge(key, ord('a'), ord('z')) + judge(key, ord('0'), ord('9'))
unknown_list = list(unknown)
print(unknown_list)
combination = list(itertools.permutations(unknown_list,4))
for i in range(len(combination)):
    key_new = key.replace('****', ''.join(list(combination[i])))
    print(key_new)
    decrypt(c, key_new)
```
输出结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210429205713681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
可以看到会有很多重复的内容
应该是由于有些字符在编码表中没有对应的字符，或者对应的字符在不同排列组合的编码表中的位置相同
结果为：wctf2120{base64_1s_v3ry_e@sy_and_fuN}



## 结语

希望继续坚持