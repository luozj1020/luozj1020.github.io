---
title: BUUCTF 每日打卡 2021-7-19
date: 2021-07-19
tags: Crypto
mathjax: true
---

# 引言

上午学了4个小时车，只能下午来更了（



## [NPUCTF2020]认清形势，建立信心

加密代码如下：

```python
from Crypto.Util.number import *
from gmpy2 import *
from secret import flag

p = getPrime(25)
e = # Hidden
q = getPrime(25)
n = p * q
m = bytes_to_long(flag.strip(b"npuctf{").strip(b"}"))

c = pow(m, e, n)
print(c)
print(pow(2, e, n))
print(pow(4, e, n))
print(pow(8, e, n))

'''
169169912654178
128509160179202
518818742414340
358553002064450
'''
```
题目给了$2^e\space mod \space n$，$4^e\space mod \space n=2^2e\space mod \space n$ 和 $8^e\space mod \space n=2^3e\space mod \space n$分别记为c2, c4, c8
容易发现，
$$
2^e\times2^e\times2^e \space mod \space n = 2^e\times4^e \space mod \space n  = 8^e \space mod \space n 
$$
由此我们可以计算```c2*c2*c2-c8```和```c2*c4-c8```得到$n$的倍数，对两数取最小公倍数再分解质因数，得到符合条件的大质数即为p和q
代码如下：

```python
import gmpy2

c = 169169912654178
c2 = 128509160179202
c4 = 518818742414340
c8 = 358553002064450

print(gmpy2.gcd(c2*c4-c8, c2*c2*c2-c8))
# 1054494004042394
```
分解质因数：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210719173225219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
但是这题隐藏了e，所以不能直接RSA解密，还需要求e
这是一个离散对数问题，可以参考我[2021-5-9的博客](https://blog.csdn.net/weixin_52446095/article/details/116573356?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162668720416780274174350%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162668720416780274174350&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-116573356.pc_v2_rank_blog_default&utm_term=%E7%A6%BB%E6%95%A3&spm=1018.2226.3001.4450)
完整解密代码如下：
```python
from Crypto.Util.number import *
import gmpy2
import sympy

c = 169169912654178
c2 = 128509160179202
c4 = 518818742414340
c8 = 358553002064450

print(gmpy2.gcd(c2*c4-c8, c2*c2*c2-c8))
p = 18195301
q = 28977097
e = sympy.discrete_log(p*q, c2, 2)
print(e)
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, p*q)
print(long_to_bytes(m))
```
结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210719173444760.png)



## [BJDCTF2020]伏羲六十四卦

题目给了一段文本：
这是什么，怎么看起来像是再算64卦！！！

密文:升随临损巽睽颐萃小过讼艮颐小过震蛊屯未济中孚艮困恒晋升损蛊萃蛊未济巽解艮贲未济观豫损蛊晋噬嗑晋旅解大畜困未济随蒙升解睽未济井困未济旅萃未济震蒙未济师涣归妹大有

嗯？为什么还有个b呢?
b=7

flag：请按照格式BJD{}

还给了一段意义不明的加密代码：
```python
# -- coding:UTF-8 --
from secret import flag

def encrpyt5():
    enc=''
    for i in flag:
        enc+=chr((a*(ord(i)-97)+b)%26+97)
    return(enc)

def encrypt4():
    temp=''
    offset=5
    for i in range(len(enc)):
        temp+=chr(ord(enc[i])-offset-i)
    return(temp)
```
我还特地取搜了一下[伏羲六十四卦](https://zh.wikipedia.org/wiki/%E5%85%AD%E5%8D%81%E5%9B%9B%E5%8D%A6)，发现密文的内容就是六十四卦的内容
没思路，只好找[wp](https://blog.csdn.net/weixin_44110537/article/details/107494966)
原来是要把六十四卦按顺序转化成6位二进制数，再8位一组转化成文本
结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210719174358694.png)
容易联想到是base64加密，尝试解密，结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/202107191744409.png)
好丑，是不是解错了？
这时就要用题目给的加密代码了
观察可得，明文先经过了encrpyt5，然后经过了encrypt4
那就先"decrypt4"
结果为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210719174745401.png)
看起来接近答案了
但是看encrpyt5，发现题目给了b，但是没给a，就很难受
wp采用爆破的方法，就借(chao)鉴(xi)了一下
完整解密代码如下：
```python
# -*- coding:utf-8 -*-

import base64

def decrypt4(c):
    temp = ''
    offset = 5
    for i in range(len(c)):
        temp += chr(ord(c[i])+offset+i)
    print(temp)
    return temp

def encrpyt5(c):
    b = 7
    for a in range(1, 200):
        temp = ''
        for i in c:
            for k in range(200):
                if (ord(i) - 97 + 26 * k - b) % a == 0:
                    temp += chr((ord(i) - 97 - 7 + 26 * k) // a + 97)
                    break
        if len(c) == len(temp) and 'flag' in temp:
            print(temp)

s = '升随临损巽睽颐萃小过讼艮颐小过震蛊屯未济中孚艮困恒晋升损蛊萃蛊未济巽解艮贲未济观豫损蛊晋噬嗑晋旅解大畜困未济随蒙升解睽未济井困未济旅萃未济震蒙未济师涣归妹大有'
table = {'坤': '000000', '剥': '000001', '比': '000010', '观': '000011', '豫': '000100', '晋': '000101', '萃': '000110', '否': '000111', '谦': '001000', '艮': '001001', '蹇': '001010', '渐': '001011', '小过': '001100', '旅': '001101', '咸': '001110', '遁': '001111', '师': '010000', '蒙': '010001', '坎': '010010', '涣': '010011', '解': '010100', '未济': '010101', '困': '010110', '讼': '010111', '升': '011000', '蛊': '011001', '井': '011010', '巽': '011011', '恒': '011100', '鼎': '011101', '大过': '011110', '姤': '011111', '复': '100000', '颐': '100001', '屯': '100010', '益': '100011', '震': '100100', '噬嗑': '100101', '随': '100110', '无妄': '100111', '明夷': '101000', '贲': '101001', '既济': '101010', '家人': '101011', '丰': '101100', '离': '101101', '革': '101110', '同人': '101111', '临': '110000', '损': '110001', '节': '110010', '中孚': '110011', '归妹': '110100', '睽': '110101', '兑': '110110', '履': '110111', '泰': '111000', '大畜': '111001', '需': '111010', '小畜': '111011', '大壮': '111100', '大有': '111101', '夬': '111110', '乾': '111111'}
b = ''
i = 0
while i < len(s):
    try:
        b += table[s[i]]
        i += 1
    except KeyError:
        b += table[s[i]+s[i+1]]
        i += 2

x = ''
for i in range(0, len(b), 8):
    x += chr(int(b[i:i+8], 2))
print(x)
x = base64.b64decode(x).decode()
print(x)
x = decrypt4(x)
encrpyt5(x)
```
结果为：![在这里插入图片描述](https://img-blog.csdnimg.cn/20210719174959920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjQ0NjA5NQ==,size_16,color_FFFFFF,t_70)
BJD congratulation son getting the flag？？？（wtm）
套上flag{}即可



## 结语

希望继续坚持
